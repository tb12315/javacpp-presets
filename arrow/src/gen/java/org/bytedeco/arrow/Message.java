// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.arrow.global.arrow.*;


// Read interface classes. We do not fully deserialize the flatbuffers so that
// individual fields metadata can be retrieved from very large schema without
//

/** \class Message
 *  \brief An IPC message including metadata and body */
@Namespace("arrow::ipc") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class Message extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Message(Pointer p) { super(p); }

  public enum Type { NONE(0), SCHEMA(1), DICTIONARY_BATCH(2), RECORD_BATCH(3), TENSOR(4), SPARSE_TENSOR(5);

      public final int value;
      private Type(int v) { this.value = v; }
      private Type(Type e) { this.value = e.value; }
      public Type intern() { for (Type e : values()) if (e.value == value) return e; return this; }
      @Override public String toString() { return intern().name(); }
  }

  /** \brief Construct message, but do not validate
   * 
   *  Use at your own risk; Message::Open has more metadata validation */
  public Message(@Const @SharedPtr @ByRef ArrowBuffer metadata, @Const @SharedPtr @ByRef ArrowBuffer body) { super((Pointer)null); allocate(metadata, body); }
  private native void allocate(@Const @SharedPtr @ByRef ArrowBuffer metadata, @Const @SharedPtr @ByRef ArrowBuffer body);

  /** \brief Create and validate a Message instance from two buffers
   * 
   *  @param metadata [in] a buffer containing the Flatbuffer metadata
   *  @param body [in] a buffer containing the message body, which may be null
   *  @param out [out] the created message
   *  @return Status */
  
  ///
  public static native @ByVal Status Open(@Const @SharedPtr @ByRef ArrowBuffer metadata,
                       @Const @SharedPtr @ByRef ArrowBuffer body, @UniquePtr Message out);

  /** \brief Read message body and create Message given Flatbuffer metadata
   *  @param metadata [in] containing a serialized Message flatbuffer
   *  @param stream [in] an InputStream
   *  @param out [out] the created Message
   *  @return Status
   * 
   *  \note If stream supports zero-copy, this is zero-copy */
  
  ///
  public static native @ByVal Status ReadFrom(@SharedPtr @ByVal ArrowBuffer metadata, InputStream stream,
                           @UniquePtr Message out);

  /** \brief Read message body from position in file, and create Message given
   *  the Flatbuffer metadata
   *  @param offset [in] the position in the file where the message body starts.
   *  @param metadata [in] containing a serialized Message flatbuffer
   *  @param file [in] the seekable file interface to read from
   *  @param out [out] the created Message
   *  @return Status
   * 
   *  \note If file supports zero-copy, this is zero-copy */
  
  ///
  public static native @ByVal Status ReadFrom(@Cast("const int64_t") long offset, @SharedPtr @ByVal ArrowBuffer metadata,
                           RandomAccessFile file, @UniquePtr Message out);

  /** \brief Return true if message type and contents are equal
   * 
   *  @param other another message
   *  @return true if contents equal */
  
  ///
  public native @Cast("bool") boolean Equals(@Const @ByRef Message other);

  /** \brief the Message metadata
   * 
   *  @return buffer */
  
  ///
  public native @SharedPtr @ByVal ArrowBuffer metadata();

  /** \brief the Message body, if any
   * 
   *  @return buffer is null if no body */
  public native @SharedPtr @ByVal ArrowBuffer body();

  /** \brief The expected body length according to the metadata, for
   *  verification purposes */
  public native @Cast("int64_t") long body_length();

  /** \brief The Message type */
  public native Type type();

  /** \brief The Message metadata version */
  public native MetadataVersion metadata_version();

  
  ///
  public native @Const Pointer header();

  /** \brief Write length-prefixed metadata and body to output stream
   * 
   *  @param file [in] output stream to write to
   *  @param options [in] IPC writing options including alignment
   *  @param output_length [out] the number of bytes written
   *  @return Status */
  public native @ByVal Status SerializeTo(OutputStream file, @Const @ByRef IpcOptions options,
                       @Cast("int64_t*") LongPointer output_length);
  public native @ByVal Status SerializeTo(OutputStream file, @Const @ByRef IpcOptions options,
                       @Cast("int64_t*") LongBuffer output_length);
  public native @ByVal Status SerializeTo(OutputStream file, @Const @ByRef IpcOptions options,
                       @Cast("int64_t*") long[] output_length);

  /** \brief Return true if the Message metadata passes Flatbuffer validation */
  public native @Cast("bool") boolean Verify();

  /** \brief Whether a given message type needs a body. */
  public static native @Cast("bool") boolean HasBody(Type type);
  public static native @Cast("bool") boolean HasBody(@Cast("arrow::ipc::Message::Type") int type);
}
