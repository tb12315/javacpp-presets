// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow_dataset;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import org.bytedeco.arrow.*;
import static org.bytedeco.arrow.global.arrow.*;
import org.bytedeco.parquet.*;
import static org.bytedeco.arrow.global.parquet.*;

import static org.bytedeco.arrow.global.arrow_dataset.*;


/** Represents an expression tree */
@Namespace("arrow::dataset") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow_dataset.class)
public class Expression extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Expression(Pointer p) { super(p); }


  /** Returns true iff the expressions are identical; does not check for equivalence.
   *  For example, (A and B) is not equal to (B and A) nor is (A and not A) equal to
   *  (false). */
  public native @Cast("bool") boolean Equals(@Const @ByRef Expression other);

  /** Validate this expression for execution against a schema. This will check that all
   *  reference fields are present (fields not in the schema will be replaced with null)
   *  and all subexpressions are executable. Returns the type to which this expression
   *  will evaluate. */
  public native @ByVal DataTypeResult Validate(@Const @ByRef Schema schema);

  /** Return a simplified form of this expression given some known conditions.
   *  For example, (a > 3).Assume(a == 5) == (true). This can be used to do less work
   *  in ExpressionFilter when partition conditions guarantee some of this expression.
   *  In the example above, *no* filtering need be done on record batches in the
   *  partition since (a == 5). */
  public native @ByVal ExpressionResult Assume(@Const @ByRef Expression given);

  /** Evaluate this expression against each row of a RecordBatch.
   *  Returned Datum will be of either SCALAR or ARRAY kind.
   *  A return value of ARRAY kind will have length == batch.num_rows()
   *  An return value of SCALAR kind is equivalent to an array of the same type whose
   *  slots contain a single repeated value. */
  public native @ByVal DatumResult Evaluate(FunctionContext ctx,
                                            @Const @ByRef RecordBatch batch);

  /** returns a debug string representing this expression */
  public native @StdString String ToString();

  public native ExpressionType.type type();

  /** If true, this Expression is a ScalarExpression wrapping a null scalar. */
  public native @Cast("bool") boolean IsNull();

  /** If true, this Expression is a ScalarExpression wrapping a
   *  BooleanScalar. Its value may be retrieved at the same time. */
  public native @Cast("bool") boolean IsTrivialCondition(@Cast("bool*") BoolPointer value/*=nullptr*/);
  public native @Cast("bool") boolean IsTrivialCondition();
  public native @Cast("bool") boolean IsTrivialCondition(@Cast("bool*") boolean[] value/*=nullptr*/);

  /** Copy this expression into a shared pointer. */
  public native @SharedPtr Expression Copy();
}
